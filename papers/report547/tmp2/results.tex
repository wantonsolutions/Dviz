%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Results}
\label{sec:res}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

To evaluate both the increse in performance gains from our
archetecture transfer we ran a performance evalutation. In addition to
compairing our Go server to a JavaScript baseline we also compaire the
performance gaings from running single v.s. multithreaded t-SNE. We
close our evaluation with an accuracy measure of k-means clustering as
a technique for logically grouping t-SNE clusters.

\textbf{Experimental setup.} We ran all our experiments on an Intel
machine with a 4 core i5 CPU and 8GB of memory. The machine was
running Ubuntu 14.04. and all applications were compiled using Go 1.6
for Linux/amd64. Experiments were run using a trace file containing
362 trace entries, with 80 variables per trace entry with a size of
1.5MB.

\subsection{XOR distance and t-SNE}

Calculating XOR distances is an imbarisingly paralell task.
Figure~\ref{fig:singlevsmultxor} shows our scaling results taken from
incrementing the number of threads used to compute the distance.
Although the algorithm is easlily parallizable, a master thread must
still aggreate the results generated by the working threads, and wait
for the final straglers (threads which are scheduled less frequently
or run slower) to complete their execution. The average time achieved
from running XOR distance on 4 cores was 1.75s.


\begin{figure}[t]
\centering
    \includegraphics[width=.5\textwidth]{fig/singlevsmultixor.png}

    \caption{ Single v.s. Multi threaded execution of XOR distance.
    Multi threaded gains slightly more than a 3x speedup running on 4
    cores.}

    \label{fig:singlevsmultixor}
\end{figure}

Prior to refactoring running t-SNE for 20 itterations, each of which
made a call to a single threaded XOR function required 507s or ~8min
on average. Post go migration, and XOR caching single threaded
latencies for 20 itterations dropped to an average of 1.1s. To test
the scalablity of our mulit threaded t-SNE we incrementally added
threads to additional cores on our test rig. The average time obtained
from executing 20 itterations of multithreaded t-SNE on 4 cores was
0.47s.

\begin{figure}[t]
\centering
    \includegraphics[width=.5\textwidth]{fig/singlevsmulti.png}

    \caption{
        Single v.s. Multi threaded execution of t-SNE. Multi threaded gains a 2x speedup running on 4 cores.
    }

    \label{fig:singlevsmulti}
\end{figure}

\subsection{Clustering}

We evaluated our technique of generating logical clusters with k-means
from t-SNE visual clusters by measuring it's accuracy on our sample
trace. The sample trace was taken from a replicated key value store
performing 3 large scale function, initlaization where values are read
from disk, followed by 50 puts, and 50 gets.
Figure~\ref{fig:clustering}A show a simplified gnu plot rendering of
the servers execution. Figure~\ref{fig:clustering}B Shows the results
of running k-means on the visual clusters. Initalization is colored
yellow, putting is black, and getting is coloured red. A few points
which are visually clustered with both initalization and putting are
logically clustered with getting. Using manual inspection we consider
6 of the trace points out of 362 to be classified correctly at an
accuracy of 98.3\%. We admit that non perfect classification will lead
to incorrectness when inferring cluster unique invariants. We propose
that in the future users be alble to manually classify points, which
are visable outliers.


\begin{figure}[t]
\centering
    \includegraphics[width=.5\textwidth]{fig/clustering.png}

    \caption{
        Clusters generated form a t-SNE clustered program trace. A) Show visual clusters only conected temporally. B) shows logical clustering achieved by running k-Means clustering, set for 3 clusters. Clustering accuracy 98.3\%.
    }

    \label{fig:clustering}
\end{figure}
