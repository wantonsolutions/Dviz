%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Results}
\label{sec:res}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

To evaluate both the increase in performance gains from our
architecture transfer we ran a performance evaluation. In addition to
comparing our Go server to a JavaScript baseline we also compared the
performance gains from running single v.s. multi threaded t-SNE. We
close our evaluation with an accuracy measure of k-means clustering as
a technique for logically grouping t-SNE clusters.

\textbf{Experimental setup.} We ran all our experiments on an Intel
machine with a 4 core i5 CPU and 8GB of memory. The machine was
running Ubuntu 14.04. and all applications were compiled using Go 1.6
for Linux/amd64. Experiments were run using a trace file containing
362 trace entries, with 80 variables per trace entry with a size of
1.5MB.

\subsection{XOR distance and t-SNE}

Calculating XOR distances is an embarrassingly parallel task.
Figure~\ref{fig:singlevsmultxor} shows our scaling results taken from
incrementing the number of threads used to compute the distance.
Although the algorithm is easily parallelizable, a master thread must
still aggregate the results generated by the working threads, and wait
for the final stragglers (threads which are scheduled less frequently
or run slower) to complete their execution. The average time achieved
from running XOR distance on 4 cores was 1.75s.


\begin{figure}[t]
\centering
    \includegraphics[width=.5\textwidth]{fig/singlevsmultixor.png}

    \caption{ Single v.s. Multi threaded execution of XOR distance.
    Multi threaded gains slightly more than a 3x speedup running on 4
    cores.}

    \label{fig:singlevsmultixor}
\end{figure}

Prior to refactoring running t-SNE for 20 iterations, each of which
made a call to a single threaded XOR function required 507s or ~8min
on average. Post go migration, and XOR caching single threaded
latencies for 20 iterations dropped to an average of 1.1s. To test
the scalability of our mulit threaded t-SNE we incrementally added
threads to additional cores on our test rig. The average time obtained
from executing 20 iterations of multi threaded t-SNE on 4 cores was
0.47s.

\begin{figure}[t]
\centering
    \includegraphics[width=.5\textwidth]{fig/singlevsmulti.png}

    \caption{
        Single v.s. Multi threaded execution of t-SNE. Multi threaded gains a 2x speedup running on 4 cores.
    }

    \label{fig:singlevsmulti}
\end{figure}

\subsection{Clustering}

We evaluated our technique of generating logical clusters with k-means
from t-SNE visual clusters by measuring it's accuracy on our sample
trace. The sample trace was taken from a replicated key value store
performing 3 large scale function, initialization where values are read
from disk, followed by 50 puts, and 50 gets.
Figure~\ref{fig:clustering}A show a simplified gnu plot rendering of
the servers execution. Figure~\ref{fig:clustering}B Shows the results
of running k-means on the visual clusters. Initialization is colored
yellow, putting is black, and getting is coloured red. A few points
which are visually clustered with both initialization and putting are
logically clustered with getting. Using manual inspection we consider
6 of the trace points out of 362 to be classified correctly at an
accuracy of 98.3\%. We admit that non perfect classification will lead
to incorrectness when inferring cluster unique invariants. We propose
that in the future users be able to manually classify points, which
are visible outliers.


\begin{figure}[t]
\centering
    \includegraphics[width=.5\textwidth]{fig/clustering.png}

    \caption{
        Clusters generated form a t-SNE clustered program trace. A) Show visual clusters only connected temporally. B) shows logical clustering achieved by running k-Means clustering, set for 3 clusters. Clustering accuracy 98.3\%.
    }

    \label{fig:clustering}
\end{figure}
